### DO NOT EDIT THIS FILE
### This file is auto-generated by the Dyad command-line compiler.
### If you edit this code it is likely to get overwritten.
### Instead, update the Dyad source code and regenerate this file


@doc Markdown.doc"""
   VehicleBody(; name)

============================================================================
VehicleBody Component
============================================================================

Description: Longitudinal and pitch dynamics of vehicle with front/rear axles
Domain: Translational mechanics with pitch dynamics

Physics to Model:
- Longitudinal: Newton's second law (F = ma)
- Pitch dynamics: Load transfer during acceleration/braking
- Aerodynamic drag (quadratic with velocity)
- Rolling resistance (proportional to normal forces)
- Grade resistance (weight component on slope)
- Normal force distribution (front/rear axles)

Interface:
- contact_front: WheelContact (front axle - traction + normal force)
- contact_rear: WheelContact (rear axle - traction + normal force)

Status: Empty skeleton - students implement physics
Reference: Documentation/Components/VehicleBody.md

TODO: Add parameters
Example:
parameter m::Mass = 1500.0               # Vehicle mass [kg]
parameter L::Length = 2.7                # Wheelbase [m]
parameter h_cg::Length = 0.5             # CG height above ground [m]
parameter a::Length = 1.2                # Distance CG to front axle [m]
parameter b::Length = 1.5                # Distance CG to rear axle [m]
parameter Cd::Real = 0.32                # Drag coefficient [-]
parameter A::Area = 2.2                  # Frontal area [m²]
parameter rho::Density = 1.225           # Air density [kg/m³]
parameter Crr::Real = 0.015              # Rolling resistance coefficient [-]
parameter g::Acceleration = 9.81         # Gravitational acceleration [m/s²]
parameter theta::Angle = 0.0             # Road grade angle [rad]

TODO: Add variables
Example:
variable v::Velocity                     # Longitudinal velocity [m/s]
variable a::Acceleration                 # Longitudinal acceleration [m/s²]
variable F_drag::Force                   # Aerodynamic drag force [N]
variable F_roll_front::Force             # Front rolling resistance [N]
variable F_roll_rear::Force              # Rear rolling resistance [N]
variable F_grade::Force                  # Grade resistance force [N]
variable F_traction_front::Force         # Front traction force [N]
variable F_traction_rear::Force          # Rear traction force [N]
variable N_front::Force                  # Front axle normal force [N]
variable N_rear::Force                   # Rear axle normal force [N]
variable N_static_front::Force           # Static front normal (no accel) [N]
variable N_static_rear::Force            # Static rear normal (no accel) [N]
variable delta_N::Force                  # Load transfer magnitude [N]

TODO: Implement physics
Hints:
1. Extract velocity: v = der(flange_front.s) = der(flange_rear.s) (same velocity)
2. Extract traction forces: F_traction_front = -flange_front.f, F_traction_rear = -flange_rear.f
3. Calculate static normal forces (no acceleration):
- N_static_front = m*g*cos(theta) * b/L  (weight on front, using rear moment arm)
- N_static_rear = m*g*cos(theta) * a/L   (weight on rear, using front moment arm)
4. Calculate load transfer due to longitudinal acceleration:
- delta_N = m*a*h_cg/L  (positive during accel = weight shifts rear)
- N_front = N_static_front - delta_N
- N_rear = N_static_rear + delta_N
5. Calculate drag: F_drag = 0.5*rho*Cd*A*v^2 * sign(v)
6. Calculate rolling resistance per axle: F_roll = Crr * N * sign(v)
7. Calculate grade resistance: F_grade = m*g*sin(theta)
8. Longitudinal dynamics: m*a = F_traction_front + F_traction_rear - F_drag - F_roll_front - F_roll_rear - F_grade
9. Connect normal forces to flanges: flange_normal_front.f = -N_front, flange_normal_rear.f = -N_rear
10. Enforce kinematic constraints: flange_front.s = flange_rear.s (same position)

Remember:
- Load transfer during acceleration: weight shifts to rear (N_rear increases)
- Load transfer during braking: weight shifts to front (N_front increases)
- Normal forces must sum to total weight: N_front + N_rear = m*g*cos(theta)
- Drag and rolling resistance oppose motion (check signs!)
- Handle v=0 smoothly (avoid discontinuities)
- Wheelbase: L = a + b
- Verify force balance and moment balance (about CG)
============================================================================

## Connectors

 * `contact_front` - ============================================================================
WheelContact Connector
============================================================================

This connector represents the mechanical interface between a wheel and
vehicle body, combining both traction (tangential) and normal (vertical)
forces along with their corresponding positions.

Physical Interpretation:
- s_traction: Longitudinal position of the contact point [m]
- f_traction: Traction force (tangential to road, propels vehicle) [N]
- s_normal: Vertical position of the contact point [m] (typically fixed)
- f_normal: Normal force (perpendicular to road, load on wheel) [N]

Sign Conventions:
- f_traction > 0: Force pushing vehicle forward (from wheel perspective)
- f_normal > 0: Force pushing wheel down (weight on wheel)

Usage Example:
In Wheel component:
contact = WheelContact()  # Connect to vehicle body
# Wheel receives: N = -contact.f_normal (normal force from body)
# Wheel provides: F_traction via contact.f_traction

In VehicleBody component:
contact_rear = WheelContact()  # Connect to rear wheels
# Body provides: N via contact_rear.f_normal
# Body receives: F_traction from wheels via contact_rear.f_traction

Connection Pattern:
connect(wheel_left.contact, vehicle.contact_rear)
connect(wheel_right.contact, vehicle.contact_rear)

This single connection handles BOTH traction and normal forces automatically!

============================================================================ ([`WheelContact`](@ref))
 * `contact_rear` - ============================================================================
WheelContact Connector
============================================================================

This connector represents the mechanical interface between a wheel and
vehicle body, combining both traction (tangential) and normal (vertical)
forces along with their corresponding positions.

Physical Interpretation:
- s_traction: Longitudinal position of the contact point [m]
- f_traction: Traction force (tangential to road, propels vehicle) [N]
- s_normal: Vertical position of the contact point [m] (typically fixed)
- f_normal: Normal force (perpendicular to road, load on wheel) [N]

Sign Conventions:
- f_traction > 0: Force pushing vehicle forward (from wheel perspective)
- f_normal > 0: Force pushing wheel down (weight on wheel)

Usage Example:
In Wheel component:
contact = WheelContact()  # Connect to vehicle body
# Wheel receives: N = -contact.f_normal (normal force from body)
# Wheel provides: F_traction via contact.f_traction

In VehicleBody component:
contact_rear = WheelContact()  # Connect to rear wheels
# Body provides: N via contact_rear.f_normal
# Body receives: F_traction from wheels via contact_rear.f_traction

Connection Pattern:
connect(wheel_left.contact, vehicle.contact_rear)
connect(wheel_right.contact, vehicle.contact_rear)

This single connection handles BOTH traction and normal forces automatically!

============================================================================ ([`WheelContact`](@ref))
"""
@component function VehicleBody(; name)
  __params = Any[]
  __vars = Any[]
  __systems = System[]
  __guesses = Dict()
  __defaults = Dict()
  __initialization_eqs = []
  __eqs = Equation[]

  ### Symbolic Parameters

  ### Variables

  ### Constants
  __constants = Any[]

  ### Components
  push!(__systems, @named contact_front = ESPDComponents.VehicleDynamics.Connectors.WheelContact())
  push!(__systems, @named contact_rear = ESPDComponents.VehicleDynamics.Connectors.WheelContact())

  ### Guesses

  ### Defaults

  ### Initialization Equations

  ### Assertions
  __assertions = []

  ### Equations
  # Placeholder to prevent compilation error (REMOVE when implementing):
  push!(__eqs, contact_front.f_traction ~ 0)
  push!(__eqs, contact_rear.f_traction ~ 0)
  push!(__eqs, contact_front.f_normal ~ 0)
  push!(__eqs, contact_rear.f_normal ~ 0)
  # Kinematic constraint: both axles move together
  push!(__eqs, contact_front.s_traction ~ contact_rear.s_traction)
  # Normal positions fixed at ground level
  push!(__eqs, contact_front.s_normal ~ 0)
  push!(__eqs, contact_rear.s_normal ~ 0)

  # Return completely constructed System
  return System(__eqs, t, __vars, __params; systems=__systems, defaults=__defaults, guesses=__guesses, name, initialization_eqs=__initialization_eqs, assertions=__assertions)
end
export VehicleBody
