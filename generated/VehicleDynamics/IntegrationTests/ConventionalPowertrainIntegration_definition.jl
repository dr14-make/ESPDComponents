### DO NOT EDIT THIS FILE
### This file is auto-generated by the Dyad command-line compiler.
### If you edit this code it is likely to get overwritten.
### Instead, update the Dyad source code and regenerate this file


@doc Markdown.doc"""
   ConventionalPowertrainIntegration(; name)

============================================================================
Conventional Powertrain - Integration Test
============================================================================

This test connects all components together in a complete vehicle system
to verify that interfaces are compatible and the system runs.

System Architecture:
Throttle → Engine → Gearbox → Differential ─┬→ Brake_L → Wheel_L ─┐
Gear_Cmd ─────────────┘                     │                      ├→ VehicleBody → Ground
Brake_Cmd ──────────────────────────────────┴→ Brake_R → Wheel_R ─┘

Purpose:
- Verify all component interfaces connect correctly
- Validate system-level behavior
- Test complete power flow from engine to wheels to vehicle

Note: This test requires ALL components to be implemented first!

Reference: Documentation/task.md (Phase 3)
============================================================================
========== CONTROL CONNECTIONS ==========
TODO: Connect control signals
connect(throttle_cmd.y, engine.throttle_input)
connect(gear_cmd.y, gearbox.gear_input)
connect(brake_cmd.y, brake_left.brake_input)
connect(brake_cmd.y, brake_right.brake_input)
========== POWERTRAIN CHAIN ==========
TODO: Connect powertrain components
connect(engine.flange, gearbox.flange_in)
connect(gearbox.flange_out, differential.flange_input)
========== LEFT SIDE: DIFFERENTIAL → BRAKE → WHEEL ==========
TODO: Connect left side
connect(differential.flange_left, brake_left.flange_a)
connect(brake_left.flange_b, wheel_left.flange_rot)
========== RIGHT SIDE: DIFFERENTIAL → BRAKE → WHEEL ==========
TODO: Connect right side
connect(differential.flange_right, brake_right.flange_a)
connect(brake_right.flange_b, wheel_right.flange_rot)
========== WHEELS TO VEHICLE BODY ==========
TODO: Connect wheels to vehicle traction flanges
Note: For rear-wheel drive, connect to rear axle
connect(wheel_left.flange_trans, vehicle.flange_rear)
connect(wheel_right.flange_trans, vehicle.flange_rear)
========== NORMAL FORCES: VEHICLE TO WHEELS ==========
TODO: Connect normal forces from vehicle to wheels
connect(vehicle.flange_normal_rear, wheel_left.flange_normal)
connect(vehicle.flange_normal_rear, wheel_right.flange_normal)
Note: If front wheels also driven, connect similarly to flange_front and flange_normal_front
========== VEHICLE TO GROUND ==========
TODO: Connect vehicle axles to ground
connect(vehicle.flange_front, ground.flange)
connect(vehicle.flange_rear, ground.flange)
========== INITIAL CONDITIONS ==========
TODO: Set initial conditions for all differential states
Engine:
initial engine.flange.phi = 0.0
initial der(engine.flange.phi) = 10.0  # Start at idle (~100 rad/s)
Vehicle:
initial vehicle.flange.s = 0.0
initial vehicle.v = 0.0
Wheels (if have inertia):
initial wheel_left.flange_rot.phi = 0.0
initial wheel_right.flange_rot.phi = 0.0
========== VALIDATION EXPECTATIONS ==========

What should happen:
1. Engine produces torque proportional to throttle
2. Gearbox multiplies torque, reduces speed
3. Differential splits torque equally to both wheels
4. Wheels convert rotational to translational force
5. Vehicle accelerates against drag and rolling resistance
6. System reaches steady-state or continues accelerating

Verify:
- Vehicle accelerates from rest
- Velocity increases (check sign!)
- Engine speed correlated with vehicle speed through ratios
- Power flows correctly through chain
- Energy is conserved (account for losses)
- No unrealistic values (NaN, Inf, excessive speeds)

TODO: Add analysis for integration test
analysis ConventionalPowertrainIntegration_Analysis
extends TransientAnalysis(stop = 20.0, alg = "Rodas5P")
model = ConventionalPowertrainIntegration()
end
============================================================================
SYSTEM-LEVEL VALIDATION
============================================================================

After successful integration, verify:

[ ] System compiles without errors
[ ] Simulation runs to completion
[ ] Vehicle accelerates realistically (0-60 km/h in reasonable time)
[ ] Engine speed matches expected range (idle to redline)
[ ] Gear ratios produce correct speed/torque multiplication
[ ] Wheels rotate at correct speed (kinematic constraint satisfied)
[ ] Power balance through entire chain (within tolerance)
[ ] Energy accounting: fuel energy → kinetic + drag losses + rolling losses
[ ] Braking works (if brake_cmd > 0)
[ ] System stable (no oscillations or divergence)

System-level metrics to calculate:
- 0-100 km/h acceleration time
- Top speed (when F_drag = F_traction)
- Fuel consumption estimate (integrate engine power)
- Brake distance from given speed
- Power efficiency through drivetrain

=============== # ========== POWERTRAIN COMPONENTS ==========
TODO: Instantiate engine
engine = Engine(
J = 0.15,
tau_peak = 200.0,
omega_peak = 400.0,
omega_max = 630.0,
tau_friction = 15.0
)
TODO: Instantiate gearbox
gearbox = Gearbox(
ratio = 3.0,       # Start with single ratio
efficiency = 0.95
)
TODO: Instantiate differential
differential = Differential(
ratio = 3.5
)
========== WHEEL AND BRAKE ASSEMBLIES ==========
TODO: Instantiate wheels
wheel_left = Wheel(radius = 0.3, mu = 0.8)
wheel_right = Wheel(radius = 0.3, mu = 0.8)
TODO: Instantiate brakes
brake_left = Brake(tau_max = 2000.0)
brake_right = Brake(tau_max = 2000.0)
========== VEHICLE BODY ==========
TODO: Instantiate vehicle body
vehicle = VehicleBody(
m = 1500.0,
L = 2.7,
h_cg = 0.55,
a = 1.2,
b = 1.5,
Cd = 0.32,
A = 2.2,
rho = 1.225,
Crr = 0.015,
g = 9.81,
theta = 0.0
)
========== CONTROL INPUTS ==========
TODO: Add control signals
throttle_cmd = BlockComponents.Constant(k = 0.3)   # 30% throttle
gear_cmd = BlockComponents.Constant(k = 1.0)       # 1st gear
brake_cmd = BlockComponents.Constant(k = 0.0)      # No braking
Or use time-varying signals:
throttle_cmd = BlockComponents.Step(height = 0.5, offset = 0.0, startTime = 1.0)
brake_cmd = BlockComponents.Step(height = 0.3, offset = 0.0, startTime = 10.0)
========== GROUND REFERENCE ==========
TODO: Add ground reference
ground = TranslationalComponents.Fixed()
=============================================================
"""
@component function ConventionalPowertrainIntegration(; name)
  __params = Any[]
  __vars = Any[]
  __systems = System[]
  __guesses = Dict()
  __defaults = Dict()
  __initialization_eqs = []
  __eqs = Equation[]

  ### Symbolic Parameters

  ### Variables

  ### Constants
  __constants = Any[]

  ### Components
  push!(__systems, @named engine = ESPDComponents.VehicleDynamics.Components.Engine())
  push!(__systems, @named gearbox = ESPDComponents.VehicleDynamics.Components.Gearbox())
  push!(__systems, @named differential = ESPDComponents.VehicleDynamics.Components.Differential())
  push!(__systems, @named wheel_left = ESPDComponents.VehicleDynamics.Components.Wheel())
  push!(__systems, @named wheel_right = ESPDComponents.VehicleDynamics.Components.Wheel())
  push!(__systems, @named brake_left = ESPDComponents.VehicleDynamics.Components.Brake())
  push!(__systems, @named brake_right = ESPDComponents.VehicleDynamics.Components.Brake())
  push!(__systems, @named vehicle = ESPDComponents.VehicleDynamics.Components.VehicleBody())
  push!(__systems, @named throttle_cmd = BlockComponents.Constant(k=0.3))
  push!(__systems, @named gear_cmd = BlockComponents.Constant(k=1))
  push!(__systems, @named brake_cmd = BlockComponents.Constant(k=0))
  push!(__systems, @named ground = TranslationalComponents.Fixed())

  ### Guesses

  ### Defaults

  ### Initialization Equations

  ### Assertions
  __assertions = []

  ### Equations
  # ========== CONTROL CONNECTIONS ==========
  push!(__eqs, connect(throttle_cmd.y, engine.throttle_input))
  push!(__eqs, connect(gear_cmd.y, gearbox.gear_input))
  # ========== POWERTRAIN CHAIN ==========
  push!(__eqs, connect(engine.flange, gearbox.flange_in))
  # ========== WHEELS TO VEHICLE BODY (Rear-wheel drive) ==========
  push!(__eqs, connect(wheel_left.flange_trans, vehicle.flange_rear))
  push!(__eqs, connect(wheel_right.flange_trans, vehicle.flange_rear))
  # ========== NORMAL FORCES: VEHICLE TO WHEELS ==========
  push!(__eqs, connect(vehicle.flange_normal_rear, wheel_left.flange_normal))
  push!(__eqs, connect(vehicle.flange_normal_rear, wheel_right.flange_normal))
  # ========== VEHICLE TO GROUND ==========
  push!(__eqs, connect(vehicle.flange_front, ground.flange))
  push!(__eqs, connect(vehicle.flange_rear, ground.flange))
  push!(__eqs, connect(gearbox.flange_out, differential.flange_input))
  push!(__eqs, connect(differential.flange_right, brake_right.flange_a))
  push!(__eqs, connect(brake_right.flange_b, wheel_right.flange_rot))
  push!(__eqs, connect(differential.flange_left, brake_left.flange_a))
  push!(__eqs, connect(brake_left.flange_b, wheel_left.flange_rot))
  push!(__eqs, connect(brake_cmd.y, brake_left.brake_input))
  push!(__eqs, connect(brake_cmd.y, brake_right.brake_input))

  # Return completely constructed System
  return System(__eqs, t, __vars, __params; systems=__systems, defaults=__defaults, guesses=__guesses, name, initialization_eqs=__initialization_eqs, assertions=__assertions)
end
export ConventionalPowertrainIntegration
