### DO NOT EDIT THIS FILE
### This file is auto-generated by the Dyad command-line compiler.
### If you edit this code it is likely to get overwritten.
### Instead, update the Dyad source code and regenerate this file


@doc Markdown.doc"""
   Differential(; name)

============================================================================
Differential Component
============================================================================

Description: Open differential with torque splitting and speed averaging
Domain: Rotational mechanics

Physics to Model:
- Equal torque split to left and right outputs
- Speed averaging with final drive ratio
- Kinematic constraint relating input/output speeds
- Power conservation

Interface:
- flange_input: RotationalComponents.Flange (from transmission)
- flange_left: RotationalComponents.Flange (to left wheel)
- flange_right: RotationalComponents.Flange (to right wheel)

Status: Empty skeleton - students implement physics
Reference: Documentation/Differential.md

TODO: Add parameters
Example:
parameter ratio::Real = 3.5          # Final drive ratio [-] (typical: 3.0-5.0)

TODO: Add variables
Example:
variable omega_in::AngularVelocity   # Input speed [rad/s]
variable omega_left::AngularVelocity # Left output speed [rad/s]
variable omega_right::AngularVelocity # Right output speed [rad/s]
variable tau_in::Torque              # Input torque [N⋅m]
variable tau_left::Torque            # Left output torque [N⋅m]
variable tau_right::Torque           # Right output torque [N⋅m]

TODO: Implement physics
Hints:
1. Extract speeds: omega_in = der(flange_input.phi), etc.
2. Kinematic constraint: omega_in = (omega_left + omega_right) / 2 * ratio
- Input speed is average of output speeds times ratio
- Straight line: omega_left = omega_right = omega_in / ratio
- Turning: speeds differ but average is maintained
3. Extract torques from flanges
4. Torque split (equal for open differential):
- tau_left = -tau_in * ratio / 2
- tau_right = -tau_in * ratio / 2
5. Verify power conservation: tau_in*omega_in = tau_left*omega_left + tau_right*omega_right

Remember:
- Open differential: equal torque regardless of speed difference
- Check signs carefully (power flow direction)
- One wheel on ice: speeds differ but torques equal (wheel spins!)
- Final drive ratio amplifies torque, reduces speed
============================================================================

## Connectors

 * `flange_input` - This connector represents a rotational spline with angle and torque as the potential and flow variables, respectively. ([`Spline`](@ref))
 * `flange_left` - This connector represents a rotational spline with angle and torque as the potential and flow variables, respectively. ([`Spline`](@ref))
 * `flange_right` - This connector represents a rotational spline with angle and torque as the potential and flow variables, respectively. ([`Spline`](@ref))
"""
@component function Differential(; name)
  __params = Any[]
  __vars = Any[]
  __systems = System[]
  __guesses = Dict()
  __defaults = Dict()
  __initialization_eqs = []
  __eqs = Equation[]

  ### Symbolic Parameters

  ### Variables

  ### Constants
  __constants = Any[]

  ### Components
  push!(__systems, @named flange_input = __Dyad__Spline())
  push!(__systems, @named flange_left = __Dyad__Spline())
  push!(__systems, @named flange_right = __Dyad__Spline())

  ### Guesses

  ### Defaults

  ### Initialization Equations

  ### Assertions
  __assertions = []

  ### Equations
  # Placeholder to prevent compilation error (REMOVE when implementing):
  push!(__eqs, flange_input.tau ~ 0)
  push!(__eqs, flange_left.tau ~ 0)
  push!(__eqs, flange_right.tau ~ 0)

  # Return completely constructed System
  return System(__eqs, t, __vars, __params; systems=__systems, defaults=__defaults, guesses=__guesses, name, initialization_eqs=__initialization_eqs, assertions=__assertions)
end
export Differential
