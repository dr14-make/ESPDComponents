### DO NOT EDIT THIS FILE
### This file is auto-generated by the Dyad command-line compiler.
### If you edit this code it is likely to get overwritten.
### Instead, update the Dyad source code and regenerate this file


@doc Markdown.doc"""
   Wheel(; name)

============================================================================
Wheel Component
============================================================================

Description: Rotational-translational coupling with rolling constraint
Domain: Mixed (Rotational + Translational)

Physics to Model:
- Rolling without slip: v = ω × r
- Force-torque relationship: F = τ / r
- Power conservation: P_rot = P_trans
- Optional: Wheel inertia J × α = τ_net

Interface:
- flange_rot: RotationalComponents.Flange (connects to driveline)
- flange_trans: TranslationalComponents.Flange (connects to vehicle body)

Status: Empty skeleton - students implement physics
Reference: Documentation/Wheel.md

TODO: Add parameters
Example:
parameter radius::Length = 0.3       # Rolling radius [m] (typical: 0.25-0.40)
parameter J::Inertia = 1.0           # Rotational inertia [kg⋅m²] (optional)

TODO: Add variables
Example:
variable omega::AngularVelocity      # Wheel angular velocity [rad/s]
variable v::Velocity                 # Linear velocity [m/s]
variable tau::Torque                 # Drive torque [N⋅m]
variable F::Force                    # Traction force [N]

TODO: Implement physics
Hints:
1. Extract velocities: omega = der(flange_rot.phi), v = der(flange_trans.s)
2. Kinematic constraint: v = omega * radius (rolling without slip)
3. Extract torque and force from flanges
4. Force-torque relationship: F = tau / radius
5. Verify power conservation: tau*omega = F*v
6. Optional: Add inertia dynamics

Remember:
- Check sign conventions on both flanges!
- Power should be conserved (no losses in ideal wheel)
- If adding inertia, need angular acceleration equation
============================================================================

## Connectors

 * `flange_rot` - This connector represents a rotational spline with angle and torque as the potential and flow variables, respectively. ([`Spline`](@ref))
 * `flange_trans` - This connector represents a mechanical flange with position and force as the potential and flow variables, respectively. ([`Flange`](@ref))
"""
@component function Wheel(; name)
  __params = Any[]
  __vars = Any[]
  __systems = System[]
  __guesses = Dict()
  __defaults = Dict()
  __initialization_eqs = []
  __eqs = Equation[]

  ### Symbolic Parameters

  ### Variables

  ### Constants
  __constants = Any[]

  ### Components
  push!(__systems, @named flange_rot = __Dyad__Spline())
  push!(__systems, @named flange_trans = __Dyad__Flange())

  ### Guesses

  ### Defaults

  ### Initialization Equations

  ### Assertions
  __assertions = []

  ### Equations
  # Placeholder to prevent compilation error (REMOVE when implementing):
  push!(__eqs, flange_rot.tau ~ 0)
  push!(__eqs, flange_trans.f ~ 0)

  # Return completely constructed System
  return System(__eqs, t, __vars, __params; systems=__systems, defaults=__defaults, guesses=__guesses, name, initialization_eqs=__initialization_eqs, assertions=__assertions)
end
export Wheel
